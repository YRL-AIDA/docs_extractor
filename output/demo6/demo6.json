{
    "title": "STRUCTURED NEURAL SUMMARIZATION ",
    "abstract": "Summarization of long sequences into a concise statement is a core problem in natural language processing, requiring non-trivial understanding of the input. Based on the promising results of graph neural networks on highly structured data, we develop a framework to extend existing sequence encoders with a graph component that can reason about long-distance relationships in weakly structured data such as text. In an extensive evaluation, we show that the resulting hybrid sequence-graph models outperform both pure sequence models as well as pure graph models on a range of summarization tasks. ",
    "keywords": null,
    "language": "de",
    "sections": [
        {
            "title": "Abstract",
            "text": "Summarization of long sequences into a concise statement is a core problem in natural language processing, requiring non-trivial understanding of the input. Based on the promising results of graph neural networks on highly structured data, we develop a framework to extend existing sequence encoders with a graph component that can reason about long-distance relationships in weakly structured data such as text. In an extensive evaluation, we show that the resulting hybrid sequence-graph models outperform both pure sequence models as well as pure graph models on a range of summarization tasks. ",
            "type": "abstract",
            "page_start": 0,
            "page_end": 0
        },
        {
            "title": "1 INTRODUCTION ",
            "text": "Summarization, the task of condensing a large and complex input into a smaller representation that retains the core semantics of the input, is a classical task for natural language processing systems. Automatic summarization requires a machine learning component to identify important entities and relationships between them, while ignoring redundancies and common concepts. \nCurrent approaches to summarization are based on the sequence-to-sequence paradigm over the words of some text, with a sequence encoder — typically a recurrent neural network, but sometimes a 1D-CNN (Narayan et al., 2018) or using self-attention (McCann et al., 2018) — processing the input and a sequence decoder generating the output. Recent successful implementations of this paradigm have substantially improved performance by focusing on the decoder, extending it with an attention mechanism over the input sequence and copying facilities (See et al., 2017; McCann et al., 2018). However, while standard encoders (e.g. bidirectional LSTMs) theoretically have the ability to handle arbitrary long-distance relationships, in practice they often fail to correctly handle long texts and are easily distracted by simple noise (Jia & Liang, 2017). \nIn this work, we focus on an improvement of sequence encoders that is compatible with a wide range of decoder choices. To mitigate the long-distance relationship problem, we draw inspiration from recent work on highly-structured objects (Li et al., 2015; Kipf & Welling, 2017; Gilmer et al., 2017; Allamanis et al., 2018; Cvitkovic et al., 2018). In this line of work, highly-structured data such as entity relationships, molecules and programs is modelled using graphs. Graph neural networks are then successfully applied to directly learn from these graph representations. Here, we propose to extend this idea to weakly-structured data such as natural language. Using existing tools, we can annotate (accepting some noise) such data with additional relationships (e.g. co-references) to obtain a graph. However, the sequential aspect of the input data is still rich in meaning, and thus we propose a hybrid model in which a standard sequence encoder generates rich input for a graph neural network. In our experiments, the resulting combination outperforms baselines that use pure sequence or pure graph-based representations. \nBriefly, the contributions of our work are: 1. A framework that extends standard sequence encoder models with a graph component that leverages additional structure in sequence data. 2. Application of this extension to a range of existing sequence models and an extensive evaluation on three summarization tasks from the literature. 3. We release all used code and most data at https://github.com/CoderPat/structured-neural-summarization. The C# data is not available but is derived from Allamanis et al. (2018) \npublic void Add(string name, object value = null, DbType? dbType = null, ParameterDirection? direction = null, int? size = null, byte? precision = null, byte? scale = null) { parameters[Clean(name)] = new ParamInfo{ Name = name, Value = value, ParameterDirection = direction ?? ParameterDirection.Input, DbType = dbType, Size = size, Precision = precision, Scale = scale }; } Ground truth: add a parameter to this dynamic parameter list BILSTM $\\rightarrow$ LSTM: adds a new parameter to the specified parameter BILSTM+GNN $\\rightarrow$ LSTM: creates a new instance of the dynamic type specified BILSTM+GNN $\\rightarrow$ LSTM+Pointer: add a parameter to a list of parameters \nFigure 1: An example from the dataset for the METHODDOC source code summarization task along with the outputs of a baseline and our models. In the METHODNAMING dataset, this method appears as a sample requiring to predict the name Add as a subtoken sequence of length 1. \n",
            "type": null,
            "page_start": 0,
            "page_end": 1
        },
        {
            "title": "2 STRUCTURED SUMMARIZATION TASKS ",
            "text": "In this work, we consider three summarization tasks with different properties. All tasks follow the common pattern of translating a long (structured) sequence into a shorter sequence while trying to preserve as much meaning as possible. The first two tasks are related to the summarization of source code (Figure 1), which is highly structured and thus can profit most from models that can take advantage of this structure; the final task is a classical natural language task illustrating that hybrid sequence-graph models are applicable for less structured inputs as well. \nMETHODNAMING The aim of this task is to infer the name of a function (or method in objectoriented languages, such as Java, Python and C#) given its source code (Allamanis et al., 2016). Although method names are a single token, they are usually composed of one or more subtokens (split using snake case or camelCase) and thus, the method naming task can be cast as predicting a sequence of subtokens. Consequently, method names represent an “extreme” summary of the functionality of a given function (on average, the names in the Java dataset have only 2.9 subtokens). Notably, the vocabulary of tokens used in names is very large (due to abbreviations and domainspecific jargon), but this is mitigated by the fact that $33 \\%$ of subtokens in names can be copied directly from subtokens in the method’s source code. Finally, source code is highly structured input data with known semantics, which can be exploited to support name prediction. \nMETHODDOC Similar to the first task, the aim of this task is to predict a succinct description of the functionality of a method given its source code (Barone & Sennrich, 2017). Such descriptions usually appear as documentation of methods (e.g. “docstrings” in Python or “JavaDocs” in Java). While the task shares many characteristics with the METHODNAMING task, the target sequence is substantially longer (on average 19.1 tokens in our C# dataset) and only $1 9 . 4 \\%$ of tokens in the documentation can be copied from the code. While method documentation is nearer to standard natural language than method names, it mixes project-specific jargon, code segments and often describes non-functional aspects of the code, such as performance characteristics and design considerations. \nNLSUMMARIZATION Finally, we consider the classic summarization of natural language as widely studied in NLP research. Specifically, we are interested in abstractive summarization, where given some text input (e.g. a news article) a machine learning model produces a novel natural language summary. Traditionally, NLP summarization methods treat text as a sequence of sentences and each one of them as a sequence of words (tokens). The input data has less explicitly defined structure than our first two tasks. However, we recast the task as a structured summarization problem by considering additional linguistic structure, including named entities and entity coreferences as inferred by existing NLP tools. \n",
            "type": null,
            "page_start": 1,
            "page_end": 1
        },
        {
            "title": "3 MODEL ",
            "text": "As discussed above, standard neural approaches to summarization follow the sequence-to-sequence framework. In this setting, most decoders only require a representation $^ { h }$ of the complete input sequence (e.g. the final state of an RNN) and per-token representations $h _ { t _ { i } }$ for each input token $t _ { i }$ . These token representations are then used as the “memories” of an attention mechanism (Bahdanau et al., 2014; Luong et al., 2015) or a pointer network (Vinyals et al., 2015a). \nIn this work, we propose an extension of sequence encoders that allows us to leverage known (or inferred) relationships among elements in the input data. To achieve that, we combine sequence encoders with graph neural networks (GNNs) (Li et al., 2015; Gilmer et al., 2017; Kipf & Welling, 2017). For this, we first use a standard sequential encoder (e.g. bidirectional RNNs) to obtain a pertoken representation $h _ { t _ { i } }$ , which we then feed into a GNN as the initial node representations. The resulting per-node (i.e. per-token) representations $\\boldsymbol { h } _ { t _ { i } } ^ { \\prime }$ can then be used by an unmodified decoder. Experimentally, we found this to surpass models that use either only the sequential structure or only the graph structure (see Sect. 4). We now discuss the different parts of our model in detail. \nGated Graph Neural Networks To process graphs, we follow Li et al. (2015) and briefly summarize the core concepts of GGNNs here. A graph $\\mathcal { G } = ( \\nu , \\pmb { \\mathscr { E } } , \\pmb { X } )$ is composed of a set of nodes $\\nu$ , node features $\\boldsymbol { X }$ , and a list of directed edge sets ${ \\pmb { \\mathcal { E } } } = ( { \\mathcal { E } } _ { 1 } , \\dots , { \\mathcal { E } } _ { K } )$ where $K$ is the number of edge types. Each $v \\in \\mathcal V$ is associated with a real-valued vector $\\scriptstyle { \\mathbf { { \\mathit { x } } } } _ { \\mathit { v } }$ representing the features of the node (e.g., the embedding of a string label of that node), which is used for the initial state ${ h } _ { v } ^ { ( 0 ) }$ of a node. \nInformation is propagated through the graph using neural message passing (Gilmer et al., 2017). For this, every node $v$ sends messages to its neighbors by transforming its current representation $\\boldsymbol { h } _ { v } ^ { ( i ) }$ using an edge-type dependent function $f _ { k }$ . Here, $f _ { k }$ can be an arbitrary function; we use a simple linear layer. By computing all messages at the same time, all states can be updated simultaneously. In particular, a new state for a node $v$ is computed by aggregating all incoming messages as $m _ { v } ^ { ( i ) } \\stackrel {  } { = } g ( \\{ f _ { k } ( \\pmb { h } _ { u } ^ { ( i ) } ) \\} )$ there is an edge of type $k$ from $u$ to $v \\}$ ). $g$ is an aggregation function; we use elementwise summation for $g$ . Given the aggregated message $\\mathbf { \\it { m } } _ { v } ^ { ( i ) }$ and the current state vector $\\boldsymbol { h } _ { v } ^ { ( i ) }$ of node $v$ , we can compute the new state $\\pmb { h } _ { v } ^ { ( i + 1 ) } = \\mathrm { G R U } ( \\pmb { m } _ { v } ^ { ( i ) } , \\pmb { h } _ { v } ^ { ( i ) } )$ , where GRU is the recurrent cell function of a gated recurrent unit. These dynamics are rolled out for a fixed number of timesteps $T$ , and the state vectors resulting from the final step are used as output node representations, i.e., $\\mathrm { G N N } ( ( \\mathcal { V } , \\pmb { \\mathcal { E } } , X ) ) = \\{ \\pmb { h } _ { v } ^ { ( T ) } \\} _ { v \\in \\mathcal { V } }$ . \nSequence GNNs We now explain our novel combination of GGNNs and standard sequence encoders. As input, we take a sequence $\\boldsymbol { S } = \\left[ s _ { 1 } \\ldots s _ { N } \\right]$ and $K$ binary relationships $R _ { 1 } \\ldots R _ { K } \\in S \\times S$ between elements of the sequence. For example, $R _ { = }$ could be the equality relationship $\\left\\{ \\left( s _ { i } , s _ { j } \\right) \\right. \\mid$ $s _ { i } = s _ { j } \\}$ . The choice and construction of relationships is dataset-dependent, and will be discussed in detail in Sect. 4. Given any sequence encoder $\\boldsymbol { \\mathcal { S } } \\boldsymbol { \\mathcal { E } }$ that maps $S$ to per-element representations $\\left[ \\mathbf { e } _ { 1 } \\ldots \\mathbf { e } _ { N } \\right]$ and a sequence representation e (e.g. a bidirectional RNN), we can construct the sequence GNN $\\mathcal { S } \\mathcal { E } _ { G N N }$ by simply computing ${ \\bf e } _ { 1 } ^ { \\prime } \\dots { \\bf e } _ { N } ^ { \\prime } ] = \\mathbf { G N N } ( ( S , [ R _ { 1 } \\dots R _ { K } ] , [ \\mathbf { e } _ { 1 } \\dots { \\bf e } _ { N } ] ) )$ . To obtain a graph-level representation, we use the weighted averaging mechanism from Gilmer et al. (2017). Concretely, for each node $v$ in the graph, we compute a weight $\\sigma ( w ( \\pmb { h } _ { v } ^ { ( T ) } ) ) \\in [ 0 , 1 ]$ using a learnable function $w$ and the logistic sigmoid $\\sigma$ and compute a graph-level representation as $\\begin{array} { r } { \\hat { \\mathbf { e } } \\equiv \\sum _ { 1 \\leq i \\leq N } \\sigma ( w ( \\mathbf { e } _ { i } ^ { \\prime } ) ) \\cdot \\mathbb { N } ( \\mathbf { e } _ { i } ^ { \\prime } ) } \\end{array}$ , where $\\aleph$ is another learnable projection function. We found that best results were achieved by computing the final $\\mathbf { e ^ { \\prime } }$ as $W \\cdot ( \\mathbf { e } \\hat { \\mathbf { e } } )$ for some learnable matrix $W$ . \nThis method can easily be extended to support additional nodes not present in the original sequence $S$ after running $\\mathcal { S E }$ (e.g., to accommodate meta-nodes representing sentences, or non-terminal nodes from a syntax tree). The initial node representation for these additional nodes can come from other sources, such as a simple embedding of their label. \nImplementation Details. Processing large graphs of different shapes efficiently requires to overcome some engineering challenges. For example, the CNN/DM corpus has (on average) about 900 nodes per graph. To allow efficient computation, we use the trick of Allamanis et al. (2018) where all graphs in a minibatch are “flattened” into a single graph with multiple disconnected components. The varying graph sizes also represent a problem for the attention and copying mechanisms in the \ndecoder, as they require to compute a softmax over a variable-sized list of memories. To handle this efficiently without padding, we associate each node in the (flattened) “batch” graph with the index of the sample in the minibatch from which the node originated. Then, using TensorFlow’s unsorted segment * operations, we can perform an efficient and numerically stable softmax over the variable number of representations of the nodes of each graph. \n",
            "type": null,
            "page_start": 2,
            "page_end": 3
        },
        {
            "title": "4 EVALUATION ",
            "text": "4.1 QUANTITATIVE EVALUATION \nWe evaluate Sequence GNNs on our three tasks by comparing them to models that use only sequence or graph information, as well as by comparing them to task-specific baselines. We discuss the three tasks, their respective baselines and how we present the data to the models (including the relationships considered in the graph component) next before analyzing the results. \n4.1.1 SETUP FOR METHODNAMING \nDatasets, Metrics, and Models. We consider two datasets for the METHODNAMING task. First, we consider the “Java (small)” dataset of Alon et al. (2019), re-using the train-validation-test splits they have picked. We additionally generated a new dataset from 23 open-source C# projects mined from GitHub (see below for the reasons for this second dataset), removing any duplicates. More information about these datasets can be found in Appendix C. We follow earlier work on METHOD-NAMING (Allamanis et al., 2016; Alon et al., 2019) and measure performance using the F1 score over the generated subtokens. However, since the task can be viewed as a form of (extreme) summarization, we also report ROUGE-2 and ROUGE-L scores (Lin, 2004), which we believe to be additional useful indicators for the quality of results. ROUGE-1 is omitted since it is equivalent to F1 score. We note that there is no widely accepted metric for this task and further work identifying the most appropriate metric is required. \nWe compare to the current state of the art (Alon et al., 2019), as well as a sequence-to-sequence implementation from the OpenNMT project (Klein et al.). Concretely, we combine two encoders (a bidirectional LSTM encoder with 1 layer and 256 hidden units, and its sequence GNN extension with 128 hidden units unrolled over 8 timesteps) with two decoders (an LSTM decoder with 1 layer and 256 hidden units with attention over the input sequence, and an extension using a pointer network-style copying mechanism (Vinyals et al., 2015a)). Additionally, we consider selfattention as an alternative to RNN-based sequence encoding architectures. For this, we use the Transformer (Vaswani et al., 2017) implementation in OpenNMT (i.e., using self-attention both for the decoder and the encoder) as a baseline and compare it to a version whose encoder is extended with a GNN component. \nData Representation Following the work of Allamanis et al. (2016); Alon et al. (2019), we break up all identifier tokens (i.e. variables, methods, classes, etc.) in the source code into subtokens by splitting them according to camelCase and pascal case heuristics. This allows the models to extract information from the information-rich subtoken structure, and ensures that a copying mechanism in the decoder can directly copy relevant subtokens, something that we found to be very effective for this task. All models are provided with all (sub)tokens belonging to the source code of a method, including its declaration, with the actual method name replaced by a placeholder symbol. \nTo construct a graph from the (sub)tokens, we implement a simplified form of the work of Allamanis et al. (2018). First, we introduce additional nodes for each (full) identifier token, and connect the constituent subtokens appearing in the input sequence using a INTOKEN edge; we additionally connect these nodes using a NEXTTOKEN edge. We also add nodes for the parse tree and use edges to indicate that one node is a CHILD of another. Finally, we add LASTLEXICALUSE edges to connect identifiers to their most (lexically) recent use in the source code. \n4.1.2 SETUP FOR METHODDOC \nDatasets, Metrics, and Models. We tried to evaluate on the Python dataset of Barone & Sennrich (2017) that contains pairs of method declarations and their documentation (“docstring”). However, \nfollowing the work of Lopes et al. (2017), we found extensive duplication between different folds of the dataset and were only able to reach comparable results by substantially overfitting to the training data that overlapped with the test set. We have documented details in subsection C.3 and in Allamanis (2018), and decided to instead evaluate on our new dataset of 23 open-source C# projects from above, again removing duplicates and methods without documentation. Following Barone & Sennrich (2017), we measure the BLEU score for all models. However, we also report F1, ROUGE-2 and ROUGE-L scores, which should better reflect the summarization aspect of the task. We consider the same models as for the METHODNAMING task, using the same configuration, and use the same data representation. \n4.1.3 SETUP FOR NLSUMMARIZATION \nDatasets, Metrics, and Models. We use the CNN/DM dataset (Hermann et al., 2015) using the exact data and split provided by See et al. (2017). The data is constructed from CNN and Daily Mail news articles along with a few sentences that summarize each article. To measure performance, we use the standard ROUGE metrics. We compare our model with the near-to-state-of-the-art work of See et al. (2017), who use a sequence-to-sequence model with attention and copying as basis, but have additionally substantially improved the decoder component. As our contribution is entirely on the encoder side and our model uses a standard sequence decoder, we are not expecting to outperform more recent models that introduce substantial novelty in the structure or training objective of the decoder (Chen & Bansal, 2018; Narayan et al., 2018). Again, we evaluate our contribution using an OpenNMT-based encoder/decoder combination. Concretely, we use a bidirectional LSTM encoder with 1 layer and 256 hidden units, and its sequence GNN extension with 128 hidden units unrolled over 8 timesteps. As decoder, we use an LSTM with 1 layer and 256 hidden units with attention over the input sequence, and an extension using a pointer network-style copying mechanism. \nData Representation We use Stanford CoreNLP (Manning et al., 2014) (version 3.9.1) to tokenize the text and provide the resulting tokens to the encoder. For the graph construction (Figure 2), we extract the named entities and run coreference resolution using CoreNLP. We connect tokens using a NEXT edge and introduce additional super-nodes for each sentence, connecting each token to the corresponding sentence-node using a IN edge. We also connect subsequent sentence-nodes using a NEXT edge. Then, for each multi-token named entity we create a new node, labeling it with the type of the entity and connecting it with all tokens referring to that entity using an IN edge. Finally, coreferences of entities are connected with a special REF edge. Figure 2 shows a partial graph for an article in the CNN/DM dataset. The goal of this graph construction process is to explicitly annotate important relationships that can be useful for summarization. We note that (a) in early efforts we experimented with adding dependency parse edges, but found that they do not provide significant benefits and (b) that since we retrieve the annotations from CoreNLP, they can contain errors and thus, the performance of the our method is influenced by the accuracy of the upstream annotators of named entities and coreferences. \n4.1.4 RESULTS & ANALYSIS \nWe show all results in Tab. 1. Results for models from the literature are taken from the respective papers and repeated here. Across all tasks, the results show the advantage of our hybrid sequence GNN encoders over pure sequence encoders. \nOn METHODNAMING, we can see that all GNN-augmented models are able to outperform the current specialized state of the art, requiring only simple graph structure that can easily be obtained using existing parsers for a programming language. The results in performance between the different encoder and decoder configurations nicely show that their effects are largely orthogonal. \nOn METHODDOC, the unmodified SELFATT SELFATT model already performs quite well, and the augmentation with graph data only improves the BLEU score and worsens the results on ROUGE. Inspection of the results shows that this is due to the length of predictions. Whereas the ground truth data has on average 19 tokens in each result, SELFATT $ s$ ELFATT predicts on average 11 tokens, and SELFATT+GNN SELFATT 16 tokens. Additionally, we experimented with an ablation in which a model is only using graph information, e.g., a setting comparable to a simplification of the architecture of Allamanis et al. (2018). For this, we configured the GNN to use 128-dimensional representations and unrolled it for 10 timesteps, keeping the decoder configuration as for the other models. The results indicate that this configuration performs less well than a pure sequenced model. We speculate that this is mainly due to the fact that 10 timesteps are insufficient to propagate infor-\npublic static bool TryFormat(float value, Span<byte> destination, out int bytesWritten, StandardFormat format = default) { return TryFormatFloatingPoint(float>(value, destination, out bytesWritten, format); } \nGround truth formats a single as a utf8 string  \nBiLSTM $\\rightarrow$ LSTM formats a number of bytes in a utf8 string  \nBiLSTM+GNN $\\rightarrow$ LSTM formats a timespan as a utf8 string  \nBiLSTM+GNN $\\rightarrow$ LSTM+Pointer formats a float as a utf8 string \nFigure 3: An example from the dataset for the METHODDOC source code summarization task along with the outputs of a baseline and our models. \nmation across the whole graph, especially in combination with summation as aggregation function for messages in graph information propagation. \nFinally, on NLSUMMARIZATION, our experiments show that the same model suitable for tasks on highly structured code is competitive with specialized models for natural language tasks. While there is still a gap to the best configuration of See et al. (2017) (and an even larger one to more recent work in the area), we believe that this is entirely due to our simplistic decoder and training objective, and that our contribution can be combined with these advances. \nIn Table 2 we show some ablations for NLSUMMARIZATION. As we use the same hyperparameters across all datasets and tasks, we additionally perform an experiment with the model of See et al. (2017) (as implemented in OpenNMT) but using our settings. The results achieved by these baselines trend to be a bit worse than the results reported in the original paper, which we believe is due to a lack of hyperparameter optimization for this task. We then evaluated how much the additional linguistic structure provided by CoreNLP helps. First, we add the coreference and entity annotations to the baseline BILSTM → LSTM + POINTER model (by extending the embedding of tokens with an embedding of the entity information, and inserting fresh $\\mathsf { \\Omega } ^ { \\bullet \\bullet } ; \\mathsf { R E F } 1 \\boldsymbol { \\dot { \\omega } }$ , . . . tokens at the sources/targets of co-references) and observe only minimal improvements. This suggests that our graph-based encoder is better-suited to exploit additional structured information compared to a biLSTM encoder. We then drop all linguistic structure information from our model, keeping only the sentence edges/nodes. This still improves on the baseline BILSTM → LSTM+POINTER model (in the ROUGE-2 score), suggesting that the GNN still yields improvements in the absence of linguistic structure. Finally, we add long-range dependency edges by connecting tokens with equivalent string representations of their stems and observe further minor improvements, indicating that even using only purely syntactical information, without a semantic parse, can already provide gains. \n4.2 QUALITATIVE EVALUATION \nWe look at a few sample suggestions in our dataset across the tasks. Here we highlight some observations we make that point out interesting aspects and failure cases of our model. \nFigure 4: Sample natural language translations from the CNN-DM dataset. \nMETHODDOC Figures 1 and 3 illustrate typical results of baselines and our model on the METHODDOC task (see Appendix A for more examples). The hardness of the task stems from the large number of distractors and the need to identify the most relevant parts of the input. In Figure 1, the token “parameter” and variations appears many times, and identifying the correct relationship is non-trivial, but is evidently eased by graph edges explicitly denoting these relationships. Similarly, in Figure 3, many variables are passed around, and the semantics of the method require understanding how information flows between them. \nNLSUMMARIZATION Figure 4 shows one sample summarization. More samples for this task can be found in Appendix B. First, we notice that the model produces natural-looking summaries with no noticeable negative impact on the fluency of the language over existing methods. Furthermore, the GNN-based model seems to capture the central named entity in the article and creates a summary centered around that entity. We hypothesize that the GNN component that links longdistance relationships helps capture and maintain a better “global” view of the article, allowing for better identification of central entities. Our model still suffers from repetition of information (see Appendix B), and so we believe that our model would also profit from advances such as taking coverage into account (See et al., 2017) or optimizing for ROUGE-L scores directly via reinforcement learning (Chen & Bansal, 2018; Narayan et al., 2018). \n",
            "type": null,
            "page_start": 3,
            "page_end": 7
        },
        {
            "title": "5 RELATED WORK ",
            "text": "Natural language processing research has studied summarization for a long time. Most related is work on abstractive summarization, in which the core content of a given text (usually a news article) is summarized in a novel and concise sentence. Chopra et al. (2016) and Nallapati et al. (2016) use deep learning models with attention on the input text to guide a decoder that generates a summary. See et al. (2017) and McCann et al. (2018) extend this idea with pointer networks (Vinyals et al., 2015a) to allow for copying tokens from the input text to the output summary. These approaches treat text as a simple token sequences, not explicitly exposing additional structure. In principle, deep sequence networks are known to be able to learn the inherent structure of natural language (e.g. in parsing (Vinyals et al., 2015b) and entity recognition (Lample et al., 2016)), but our experiments indicate that explicitly exposing this structure by separating concerns improves performance. \nRecent work in summarization has proposed improved training objectives for summarization, such as tracking coverage of the input document (See et al., 2017) or using reinforcement learning to directly identify actions in the decoder that improve target measures such as ROUGE-L (Chen & Bansal, 2018; Narayan et al., 2018). These objectives are orthogonal to the graph-augmented encoder discussed in this work, and we are interested in combining these efforts in future work. \nExposing more language structure explicitly has been studied over the last years, with a focus on treebased models (Tai et al., 2015). Very recently, first uses of graphs in natural language processing have been explored. Marcheggiani & Titov (2017) use graph convolutional networks to encode single sentences and assist machine translation. De Cao et al. (2018) create a graph over named entities over a set of documents to assist question answering. Closer to our work is the work of Liu et al. (2018), who use abstract meaning representation (AMR), in which the source document is first parsed into AMR graphs, before a summary graph is created, which is finally rendered in natural language. In contrast to that work we do not use AMRs but directly encode relatively simple relationships directly on the tokenized text, and do not treat summarization as a graph rewrite problem. Combining our encoder with AMRs to use richer graph structures may be a promising future direction. \nFinally, summarization in source code has also been studied in the forms of method naming, comment and documentation prediction. Method naming has been tackled with a series of models. For example, Allamanis et al. (2015) use a log-bilinear network to predict method names from features, and later extend this idea to use a convolutional attention network over the tokens of a method to predict the subtokens of names (Allamanis et al., 2016). Raychev et al. (2015) and Bichsel et al. (2016) use CRFs for a range of tasks on source code, including the inference of names for variables and methods. Recently, Alon et al. (2018; 2019) extract and encode paths from the syntax tree of a program, setting the state of the art in accuracy on method naming. \nLinking text to code can have useful applications, such as code search (Gu et al., 2018), traceability (Guo et al., 2017), and detection of redundant method comments (Louis et al., 2018). Most approaches on source code either treat it as natural language (i.e., a token sequence), or use a language parser to explicitly expose its tree structure. For example, Barone & Sennrich (2017) use a simple sequence-to-sequence baseline, whereas Hu et al. (2017) summarize source code by linearizing the abstract syntax tree of the code and using a sequence-to-sequence model. Wan et al. (2018) instead directly operate on the tree structure using tree recurrent neural networks (Tai et al., 2015). The use of additional structure on related tasks on source code has been studied recently, for example in models that are conditioned on learned traversals of the syntax tree (Bielik et al., 2016) and in graphbased approaches (Allamanis et al., 2018; Cvitkovic et al., 2018). However, as noted by Liao et al. (2018), GNN-based approaches suffer from a tension between the ability to propagate information across large distances in a graph and the computational expense of the propagation function, which is linear in the number of graph edges per propagation step. \n",
            "type": null,
            "page_start": 7,
            "page_end": 8
        },
        {
            "title": "6 DISCUSSION & CONCLUSIONS ",
            "text": "We presented a framework for extending sequence encoders with a graph component that can leverage rich additional structure. In an evaluation on three different summarization tasks, we have shown that this augmentation improves the performance of a range of different sequence models across all tasks. We are excited about this initial progress and look forward to deeper integration of mixed sequence-graph modeling in a wide range of tasks across both formal and natural languages. The key insight, which we believe to be widely applicable, is that inductive biases induced by explicit relationship modeling are a simple way to boost the practical performance of existing deep learning systems. \n",
            "type": null,
            "page_start": 8,
            "page_end": 8
        },
        {
            "title": "REFERENCES ",
            "text": "",
            "type": null,
            "page_start": 9,
            "page_end": 11
        },
        {
            "title": "A CODE SUMMARIZATION SAMPLES",
            "text": "",
            "type": null,
            "page_start": 12,
            "page_end": 12
        },
        {
            "title": "A.1 METHODDOC ",
            "text": "",
            "type": null,
            "page_start": 12,
            "page_end": 12
        },
        {
            "title": "C# Sample 1 ",
            "text": "public static bool TryConvertTo(object valueToConvert, Type resultType, IFormatProvider formatProvider, out object result){ result $=$ null; try{ result $=$ ConvertTo(valueToConvert, resultType, formatProvider); } catch (InvalidcastException){ return false; } catch (ArgumentException){ return false; } return true; } \n",
            "type": null,
            "page_start": 12,
            "page_end": 12
        },
        {
            "title": "Ground truth ",
            "text": "sets result to valuetoconvert converted to resulttype considering formatprovider for custom conversions calling the parse method and calling convert . changetype . \nBILSTM LSTM \nconverts the specified type to a primitive type . \nBILSTM+GNN LSTM \nsets result to resulttype \nBILSTM+GNN LSTM+POINTER \nsets result to valuetoconvert converted to resulttype. \n",
            "type": null,
            "page_start": 12,
            "page_end": 12
        },
        {
            "title": "C# Sample 2 ",
            "text": "public virtual Task Init(string name, IProviderRuntime providerRuntime, IProviderConfiguration config) { Log = providerRuntime GetLogger(this.Type()._FULLName); this~- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \n",
            "type": null,
            "page_start": 12,
            "page_end": 12
        },
        {
            "title": "Ground truth ",
            "text": "initializes the storage provider \nBILSTM LSTM \ncreates a grain object \nBILSTM+GNN LSTM \ninitializes the provider provider \nBILSTM+GNN LSTM+POINTER \ninitialization function to initialize the specified provider. \n",
            "type": null,
            "page_start": 12,
            "page_end": 12
        },
        {
            "title": "C# Sample 3 ",
            "text": "public void NullParameter(){ TaskParameter t = new TaskParameter(null); Assert(NULL(t.WrappedParameter); AssertEqual( TaskParameterType Null, t.ParametersType); ((INodePacketTranslatable) t).Translate( TranslationHelperss.GetWriteTranslator()); TaskParameter t2 = TaskParameter.FactoryForDeserialization( TranslationHelperss.GetReadTranslator()); Assert(NULL(t2.WrappedParameter); AssertEqual( TaskParameterType Null, t2.ParametersType); } \n",
            "type": null,
            "page_start": 12,
            "page_end": 12
        },
        {
            "title": "Ground truth ",
            "text": "BILSTM LSTM \nverifies that construction and serialization with a null parameter is ok tests that the value is a value that is a value to the specified type \nBILSTM+GNN LSTM \nverifies that construction with an parameter parameter \nBILSTM+GNN LSTM+POINTER \nverifies that construction and serialization with a parameter that is null \n",
            "type": null,
            "page_start": 12,
            "page_end": 12
        },
        {
            "title": "C# Sample 4 ",
            "text": "public override DbGeometryWellKnownValue CreateWellKnownValue DbGeometry geometryValue) { geometryValue.Checked(\"geometryValue\"); var spatialValue = geometryValue.AsSpatialValue(); DbGeometryWellKnownValue result = CreateWellKnownValue(spatialValue, \n() $\\coloneqq$ >SpatialExceptions.CouldNotCreateWellKnownGeometryValueNoSrid(\"geometryValue\"), () $\\coloneqq$ >SpatialExceptions.CouldNotCreateWellKnownGeometryValueNoWkbOrWkt(\"geometryValue\"), (srid, wkb, wkt) $\\Rightarrow$ new DbGeometryWellKnownValue() { CoordinateSystemId $\\equiv$ srid, WellKnownBinary $\\equiv$ wkb, WellKnownText $\\equiv$ wkt }); return result; } \n",
            "type": null,
            "page_start": 12,
            "page_end": 13
        },
        {
            "title": "Ground truth ",
            "text": "BILSTM LSTM \nBILSTM+GNN LSTM \nBILSTM+GNN LSTM+POINTER \ncreates an instance of t:system.data.spatial.dbgeometry value using one or both of the standard well known spatial formats. \ncreates a t:system.data.spatial.dbgeography value based on the specified well known binary value . \ncreates a new t:system.data.spatial.dbgeography instance using the specified well known spatial formats . \ncreates a new instance of the t:system.data.spatial.dbgeometry value based on the provided geometry value and returns the resulting well as known spatial formats . \n",
            "type": null,
            "page_start": 13,
            "page_end": 13
        },
        {
            "title": "A.2 METHODNAMING ",
            "text": "",
            "type": null,
            "page_start": 13,
            "page_end": 13
        },
        {
            "title": "C# Sample 1 ",
            "text": "public bool $\\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ \\_ d$ return d != null && d.Val $= =$ Val; \nGround truth equals \nBILSTM LSTM foo \nBILSTM+GNN LSTM equals \nBILSTM+GNN LSTM+POINTER equals \n",
            "type": null,
            "page_start": 13,
            "page_end": 13
        },
        {
            "title": "C# Sample 2 ",
            "text": "internal void __(string switchName,.Hashtable bag, string parameterName){ object obj $=$ bag[parameterName]; if(obj $! =$ null){ int value $=$ (int) obj; AppendSwitchIfNotNull(switchName, value.ToString(CultureInfo.InvariantCulture)); } } \nGround truth append switch with integer \nBILSTM LSTM set string \nBILSTM+GNN → LSTM append switch \nBILSTM+GNN LSTM+POINTER append switch if not null \n",
            "type": null,
            "page_start": 13,
            "page_end": 13
        },
        {
            "title": "C# Sample 3 ",
            "text": "internal static string __() {\n    var currentPlatformString = string.empty;\n    if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows)) {\n        currentPlatformString = \"WINDOWS\";\n    }\n    else if (RuntimeInformation.IsOSPlatform(OSPlatform.Linux)) {\n        currentPlatformString = \"LINUX\";\n    }\n    else if (RuntimeInformation.IsOSPlatform(OSPlatform.OSX)) {\n        currentPlatformString = \"OSX\";\n    }\n    else {\n        Assert.True(false, \"unrecognized current platform\");\n    }\n    return currentPlatformString;\n} \nGround truth get os platform as string  \nBiLSTM $\\rightarrow$ LSTM get name  \nBiLSTM+GNN $\\rightarrow$ LSTM get platform  \nBiLSTM+GNN $\\rightarrow$ LSTM+Pointer get current platform string \n",
            "type": null,
            "page_start": 13,
            "page_end": 14
        },
        {
            "title": "C# Sample 4 ",
            "text": "public override DbGeometryWellKnownValue CreateWellKnownValue DbGeometry geometryValue) { geometryValue.Checked(\"geometryValue\"); var spatialValue = geometryValue.AsSpatialValue(); DbGeometryWellKnownValue result = CreateWellKnownValue(spatialValue, (   )=>SpatialExceptions.CouldNotCreateWellKnownGeometryValueNoSrid(\"geometryValue\"), (   )=>SpatialExceptions.CouldNotCreateWellKnownGeometryValueNoWkbOrWkt(\"geometryValue\"), (srid, wkb, wkt) => new DbGeometryWellKnownValue (   ) { CoordinateSystemId = srid, WellKnownBinary = wkb, WellKnownText = wkt }); return result; } \nGround truth create well known value  \nBILSTM $\\rightarrow$ LSTM spatial geometry from xml  \nBILSTM+GNN $\\rightarrow$ LSTM geometry point  \nBILSTM+GNN $\\rightarrow$ LSTM+Pointer get well known value \n",
            "type": null,
            "page_start": 14,
            "page_end": 14
        },
        {
            "title": "Java Sample 1 ",
            "text": "public static void _ (String name, int expected, MetricsRecordBuilder rb) \\{\n\tAssert.assertEquals(\"Bad value for metric \" + name,\n\t\texpected,\n\tgetIntCounter(name, rb));\n\\} \nGround truth assert counter  \nBILSTM $\\rightarrow$ LSTM assert email value  \nBILSTM+GNN $\\rightarrow$ LSTM assert header  \nBILSTM+GNN $\\rightarrow$ LSTM+Pointer assert int counter \n",
            "type": null,
            "page_start": 14,
            "page_end": 14
        },
        {
            "title": "B NATURAL LANGUAGE SUMMARIZATION SAMPLES",
            "text": "",
            "type": null,
            "page_start": 15,
            "page_end": 15
        },
        {
            "title": "C CODE DATASETS INFORMATION ",
            "text": "",
            "type": null,
            "page_start": 16,
            "page_end": 16
        },
        {
            "title": "C.1 C# DATASET ",
            "text": "We extract the C# dataset from open-source projects on GitHub. Overall, our dataset contains 460,905 methods, 55,635 of which have a documentation comment. The dataset is split $8 5 - 5 - 1 0 \\%$ . The projects and exact state of the repositories used is listed in Table 3 \n",
            "type": null,
            "page_start": 16,
            "page_end": 16
        },
        {
            "title": "C.2 JAVA METHOD NAMING DATASETS ",
            "text": "We use the datasets and splits of Alon et al. (2019) provided by their website. Upon scanning all methods in the dataset, the size of the corpora can be seen in Table 4. More information can be found at Alon et al. (2019). \n",
            "type": null,
            "page_start": 16,
            "page_end": 16
        },
        {
            "title": "C.3 PYTHON METHOD DOCUMENTATION DATASET ",
            "text": "We use the dataset as split of Barone & Sennrich (2017) provided by their GitHub repository. Upon parsing the dataset, we get 106,065 training samples, 1,943 validation samples and 1,937 test samples. We note that $1 6 . 9 \\%$ of the documentation samples in the validation set and $1 5 . 3 \\%$ of the samples in test set have a sample with the identical natural language documentation on the training \nset. This eludes to a potential issue, described by Lopes et al. (2017). See Allamanis (2018) for a lengthier discussion of this issue. \n",
            "type": null,
            "page_start": 16,
            "page_end": 17
        }
    ],
    "references": [],
    "figures": [
        {
            "id": "Figure 1",
            "type": "image",
            "caption": [
                "Figure 2: (Partial) graph of an example input from the CNN/DM corpus. "
            ],
            "img_path": [
                "images/3e3da587bc37e6c4439d300522ec1a50d0f118387c55d8464938255a30840303.jpg"
            ],
            "page": 4
        },
        {
            "id": "Table 1",
            "type": "table",
            "caption": [
                "Table 1: Evaluation results for all models and tasks. "
            ],
            "table_body": "<table><tr><td>METHODNAMING</td><td>F1</td><td>ROUGE-2</td><td>ROUGE-L</td><td></td></tr><tr><td>Java</td><td></td><td></td><td></td><td></td></tr><tr><td>Alon et al. (2019)</td><td>43.0</td><td>-</td><td>-</td><td></td></tr><tr><td>SELFATT → SELFATT</td><td>24.9</td><td>8.3</td><td>27.4</td><td></td></tr><tr><td>SELFATT+GNN → SELFATT</td><td>44.5</td><td>20.9</td><td>43.4</td><td></td></tr><tr><td>BILSTM → LSTM</td><td>35.8</td><td>17.9</td><td>39.7</td><td></td></tr><tr><td>BILSTM+GNN → LSTM</td><td>44.7</td><td>21.1</td><td>43.1</td><td></td></tr><tr><td>BILSTM → LSTM+Pointer</td><td>42.5</td><td>22.4</td><td>45.6</td><td></td></tr><tr><td>GNN → LSTM+Pointer</td><td>50.5</td><td>24.8</td><td>48.9</td><td></td></tr><tr><td>BILSTM+GNN → LSTM+Pointer</td><td>51.4</td><td>25.0</td><td>50.0</td><td></td></tr><tr><td>C#</td><td></td><td></td><td></td><td></td></tr><tr><td>SELFATT → SELFATT</td><td>41.3</td><td>25.2</td><td>43.2</td><td></td></tr><tr><td>SELFATT+GNN → SELFATT</td><td>62.1</td><td>31.0</td><td>61.1</td><td></td></tr><tr><td>BILSTM → LSTM</td><td>48.8</td><td>32.8</td><td>51.8</td><td></td></tr><tr><td>BILSTM+GNN → LSTM</td><td>62.6</td><td>31.0</td><td>61.3</td><td></td></tr><tr><td>BILSTM → LSTM+Pointer</td><td>57.2</td><td>29.7</td><td>60.4</td><td></td></tr><tr><td>GNN → LSTM+Pointer</td><td>63.0</td><td>31.5</td><td>61.3</td><td></td></tr><tr><td>BILSTM+GNN → LSTM+Pointer</td><td>63.4</td><td>31.9</td><td>62.4</td><td></td></tr><tr><td>METHODDOC</td><td>F1</td><td>ROUGE-2</td><td>ROUGE-L</td><td>BLEU</td></tr><tr><td>C#</td><td></td><td></td><td></td><td></td></tr><tr><td>SELFATT → SELFATT</td><td>40.0</td><td>27.8</td><td>41.1</td><td>13.9</td></tr><tr><td>SELFATT+GNN → SELFATT</td><td>37.6</td><td>25.6</td><td>37.9</td><td>21.4</td></tr><tr><td>BILSTM → LSTM</td><td>35.2</td><td>15.3</td><td>30.8</td><td>10.0</td></tr><tr><td>BILSTM+GNN → LSTM</td><td>41.1</td><td>28.9</td><td>41.0</td><td>22.5</td></tr><tr><td>BILSTM → LSTM+Pointer</td><td>35.2</td><td>20.8</td><td>36.7</td><td>14.7</td></tr><tr><td>GNN → LSTM+Pointer</td><td>38.9</td><td>25.6</td><td>37.1</td><td>17.7</td></tr><tr><td>BILSTM+GNN → LSTM+Pointer (average pooling)</td><td>43.2</td><td>29.0</td><td>41.0</td><td>21.3</td></tr><tr><td>BILSTM+GNN → LSTM+Pointer</td><td>45.4</td><td>28.3</td><td>41.1</td><td>22.2</td></tr><tr><td>NLSUMMARIZATION</td><td>ROUGE-1</td><td>ROUGE-2</td><td>ROUGE-L</td><td></td></tr><tr><td>CNN/DM</td><td></td><td></td><td></td><td></td></tr><tr><td>BILSTM → LSTM</td><td>33.6</td><td>11.4</td><td>27.9</td><td></td></tr><tr><td>BILSTM+GNN → LSTM</td><td>33.0</td><td>13.3</td><td>28.3</td><td></td></tr><tr><td>See et al. (2017) (+ Pointer)</td><td>36.4</td><td>15.7</td><td>33.4</td><td></td></tr><tr><td>BILSTM → LSTM+Pointer</td><td>35.9</td><td>13.9</td><td>30.3</td><td></td></tr><tr><td>BILSTM+GNN → LSTM+Pointer</td><td>38.1</td><td>16.1</td><td>33.2</td><td></td></tr><tr><td>See et al. (2017) (+ Pointer + Coverage)</td><td>39.5</td><td>17.3</td><td>36.4</td><td></td></tr></table>",
            "img_path": "output/images/ca6f8251c14aa6e6e9962644ac1f23c32b4d3993eb68019b6822922a22a88730.jpg",
            "page": 5
        },
        {
            "id": "Table 2",
            "type": "table",
            "caption": [
                "Table 2: Ablations on CNN/DM Corpus "
            ],
            "table_body": "<table><tr><td colspan=\"2\">NLSUMMARIZATION (CNN/DM)</td><td>ROUGE-1</td><td>ROUGE-2</td><td>ROUGE-L</td></tr><tr><td colspan=\"2\">See et al. (2017) (base)</td><td>31.3</td><td>11.8</td><td>28.8</td></tr><tr><td colspan=\"2\">See et al. (2017) (+ Pointer)</td><td>36.4</td><td>15.7</td><td>33.4</td></tr><tr><td colspan=\"2\">See et al. (2017) (+ Pointer + Coverage)</td><td>39.5</td><td>17.3</td><td>36.4</td></tr><tr><td>BILSTM</td><td>→ LSTM</td><td>33.6</td><td>11.4</td><td>27.9</td></tr><tr><td>BILSTM</td><td>→ LSTM+Pointer</td><td>35.9</td><td>13.9</td><td>30.3</td></tr><tr><td>BILSTM</td><td>→ LSTM+Pointer (+ coref/entity annotations)</td><td>36.2</td><td>14.2</td><td>30.5</td></tr><tr><td>BILSTM+GNN</td><td>→ LSTM</td><td>33.0</td><td>13.3</td><td>28.3</td></tr><tr><td>BILSTM+GNN</td><td>→ LSTM+Pointer (only sentence nodes)</td><td>36.0</td><td>15.2</td><td>29.6</td></tr><tr><td>BILSTM+GNN</td><td>→ LSTM+Pointer (sentence nodes + eq edges)</td><td>36.1</td><td>15.4</td><td>30.3</td></tr><tr><td>BILSTM+GNN</td><td>→ LSTM+Pointer</td><td>38.1</td><td>16.1</td><td>33.2</td></tr></table>",
            "img_path": "output/images/dcb8aead1b59ac4bd0b0107574b293b3e8aa510abab0c751fe1390219159d585.jpg",
            "page": 6
        },
        {
            "id": "Table 3",
            "type": "table",
            "caption": [],
            "table_body": "<table><tr><td>Input: Arsenal, Newcastle United and Southampton have checked on Caen midfielder N’golo Kante. Paris-born Kante is a defensive minded player who has impressed for Caen this season and they are willing to sell for around £ 5million. Marseille have been in constant contact with Caen over signing the 24-year-old who has similarities with Lassana Diarra and Claude Makelele in terms of stature and style. N’Golo Kante is attracting interest from a host of Premier League clubs including Arsenal. Caen would be willing to sell Kante for around £ 5million.</td></tr><tr><td>Reference: n’golo kante is wanted by arsenal, newcastle and southampton. marseille are also keen on the £ 5m rated midfielder. kante has been compared to lassana diarra and claude makelele. click here for the latest premier league news.</td></tr><tr><td>See et al. (2017) (+ Pointer): arsenal, newcastle united and southampton have checked on caen midfielder n’golo kante. paris-born kante is attracting interest from a host of premier league clubs including arsenal. paris-born kante is attracting interest from a host of premier league clubs including arsenal</td></tr><tr><td>See et al. (2017) (+ Pointer + Coverage): arsenal, newcastle united and southampton have checked on caen midfielder n’golo kante. paris-born kante is a defensive minded player who has impressed for caen this season. marseille have been in constant contact with caen over signing the 24-year-old.</td></tr><tr><td>BILSTM+GNN → LSTM: marseille have been linked with caen midfielder %UNK% %UNK%. marseille have been interested from a host of premier league clubs including arsenal. caen have been interested from a host of premier league clubs including arsenal.</td></tr><tr><td>BILSTM+GNN → LSTM+Pointer n’golo kante is attracting interest from a host of premier league clubs. marseille have been in constant contact with caen over signing the 24-year-old. the 24-year-old has similarities with lassana diarra and claude makelele in terms of stature.</td></tr></table>",
            "img_path": "output/images/e5ce698356b910cf932077b962a606e2691c078e104ea53349b78faddb785376.jpg",
            "page": 7
        },
        {
            "id": "Table 4",
            "type": "table",
            "caption": [
                "Table 3: Projects in our C# dataset. Ordered alphabetically. "
            ],
            "table_body": "<table><tr><td>Name</td><td>Git SHA</td><td>Description</td></tr><tr><td>Akka.NET</td><td>6f32f6a7</td><td>Actor-based Concurrent &amp; Distributed Framework</td></tr><tr><td>AutoMapper</td><td>19d6f7fc</td><td>Object-to-Object Mapping Library</td></tr><tr><td>BenchmarkDotNet</td><td>57005f05</td><td>Benchmarking Library</td></tr><tr><td>CommonMark.NET</td><td>f3d54530</td><td>Markdown Parser</td></tr><tr><td>CoreCLR</td><td>cc5dcbd6</td><td>.NET Core Runtime</td></tr><tr><td>CoreFx</td><td>ec1671fd</td><td>.NET Foundational Libraries</td></tr><tr><td>Dapper</td><td>3c7cde28</td><td>Object Mapper Library</td></tr><tr><td>EntityFramework</td><td>c4d9a269</td><td>Object-Relational Mapper</td></tr><tr><td>Humanizer</td><td>2b1c94c4</td><td>String Manipulation and Formatting</td></tr><tr><td>Lean</td><td>90ee6aaae</td><td>Algorithms Trading Engine</td></tr><tr><td>Mono</td><td>9b9e4f4b</td><td>.NET Implementation</td></tr><tr><td>MsBuild</td><td>7f95dc15</td><td>Build Engine</td></tr><tr><td>Nancy</td><td>de458a9b</td><td>HTTP Service Framework</td></tr><tr><td>NLog</td><td>49fdd08e</td><td>Logging Library</td></tr><tr><td>Opserver</td><td>9e4d3a40</td><td>Monitoring System</td></tr><tr><td>orleans</td><td>f89c5866</td><td>Distributed Virtual Actor Model</td></tr><tr><td>Polly</td><td>f3d2973d</td><td>Resilience &amp; Transient Fault Handling Library</td></tr><tr><td>Powershell</td><td>9ac701db</td><td>Command-line Shell</td></tr><tr><td>ravendb</td><td>6437de30</td><td>Document Database</td></tr><tr><td>roslyn</td><td>8ca0a542</td><td>Compiler &amp; Code Analysis &amp; Compilation</td></tr><tr><td>ServiceStack</td><td>17f081b9</td><td>Real-time web library</td></tr><tr><td>SignalR</td><td>9b05bcb0</td><td>Push Notification Framework</td></tr><tr><td>Wox</td><td>13e6c5ee</td><td>Application Launcher</td></tr></table>",
            "img_path": "output/images/97212ffd45c47389899b16e875d51f6d4934234e6361a696c55a6d42f48c7dca.jpg",
            "page": 16
        },
        {
            "id": "Table 5",
            "type": "table",
            "caption": [
                "Table 4: The statistics of the extracted graphs from the Java method naming dataset of Alon et al. (2019). "
            ],
            "table_body": "<table><tr><td>Dataset</td><td>Train Size</td><td>Valid Size</td><td>Test Size</td></tr><tr><td>Java – Small</td><td>691,505</td><td>23,837</td><td>56,952</td></tr></table>",
            "img_path": "output/images/e9efcf7faf2760fc56146a69b0da4a5a1502edde1b1326f165f62475b9534919.jpg",
            "page": 16
        },
        {
            "id": "Table 6",
            "type": "table",
            "caption": [
                "Table 5: Graph Statistics For Datasets. "
            ],
            "table_body": "<table><tr><td>Dataset</td><td>Avg Num Nodes</td><td>Avg Num Edges</td></tr><tr><td>CNN/DM</td><td>903.2</td><td>2532.9</td></tr><tr><td>C# Method Names</td><td>125.2</td><td>239.3</td></tr><tr><td>C# Documentation</td><td>133.5</td><td>265.9</td></tr><tr><td>Java-Small Method Names</td><td>144.4</td><td>251.6</td></tr></table>",
            "img_path": "output/images/a8c7c58fe23c5fce051cc8a542e363b13732ee78d1c025fd2843ed8b6b3938d8.jpg",
            "page": 17
        }
    ]
}